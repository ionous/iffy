package core

import (
	"github.com/ionous/iffy/dl/composer"
	"github.com/ionous/iffy/object"
	"github.com/ionous/iffy/rt"
	g "github.com/ionous/iffy/rt/generic"
	"github.com/ionous/iffy/rt/safe"
)

type Sequence struct {
	Seq   string `if:"internal"` // generated at import time to provide a unique counter for each sequence
	Parts []rt.TextEval
}

// CycleText when called multiple times returns each of its elements in turn.
type CycleText struct {
	Sequence
}

// ShuffleText walks randomly through the list of elements without repeating any until they all have been shown.
// Unlike the other sequences, ShuffleText is not persistent.
type ShuffleText struct {
	Sequence
	indices []int
}

// StoppingText options returns its values in-order, once per evaluation, until the options are exhausted, then the last one is kept.
// As a special case, if there is only one option: it gets returned once, followed by the empty string forever after.
type StoppingText struct {
	Sequence
}

// sequences store fields into autogenerated targets
// if persistence wasn't necessary, we could use in-memory private fields of the commands
func (op *Sequence) updateCounter(run rt.Runtime, inc func(int, int) int) (ret int, err error) {
	if max := len(op.Parts); max > 0 {
		if p, e := run.GetField(object.Counter, op.Seq); e != nil {
			err = e
		} else {
			curr := p.Int()
			next := g.IntOf(inc(curr, max))
			if e := run.SetField(object.Counter, op.Seq, next); e != nil {
				err = e
			} else {
				ret = curr + 1
			}
		}
	}
	return
}

func (op *Sequence) getText(run rt.Runtime, onedex int) (ret g.Value, err error) {
	if i, max := onedex-1, len(op.Parts); i >= 0 && i < max {
		ret, err = safe.GetText(run, op.Parts[i])
	} else {
		ret = g.Empty
	}
	return
}

func (*CycleText) Compose() composer.Spec {
	return composer.Spec{
		Group: "cycle",
		Desc:  "Cycle Text: When called multiple times, returns each of its inputs in turn.",
		Stub:  true,
	}
}

func (op *CycleText) GetText(run rt.Runtime) (ret g.Value, err error) {
	if onedex, e := op.updateCounter(run, wrap); e != nil {
		err = cmdError(op, e)
	} else {
		ret, err = op.getText(run, onedex)
	}
	return
}

func (*ShuffleText) Compose() composer.Spec {
	return composer.Spec{
		Group: "format",
		Desc:  "Shuffle Text: When called multiple times returns its inputs at random.",
		Stub:  true,
	}
}

func (op *ShuffleText) GetText(run rt.Runtime) (ret g.Value, err error) {
	if onedex, e := op.shuffle(run); e != nil {
		err = cmdError(op, e)
	} else {
		ret, err = op.getText(run, onedex)
	}
	return
}

func (op *ShuffleText) shuffle(run rt.Runtime) (ret int, err error) {
	if curr, e := op.updateCounter(run, wrap); e != nil {
		err = e
	} else if curr, max := curr-1, len(op.Parts); curr < max {
		// uses the Fisherâ€“Yates algorithm to sort indices
		if len(op.indices) == 0 {
			op.indices = makeIndices(max)
		}
		// we pick anything b/t the start and end of our list
		j := run.Random(curr, max)
		if curr != j { // switch if they are different locations.
			op.indices[curr], op.indices[j] = op.indices[j], op.indices[curr]
		}
		// and that's the real index we use.
		ret = 1 + op.indices[curr]
	}
	return
}

func (*StoppingText) Compose() composer.Spec {
	return composer.Spec{
		Group: "format",
		Desc:  "Stopping Text: When called multiple times returns each of its inputs in turn, sticking to the last one.",
		Stub:  true,
	}
}

func (op *StoppingText) GetText(run rt.Runtime) (ret g.Value, err error) {
	if onedex, e := op.stopping(run); e != nil {
		err = cmdError(op, e)
	} else {
		ret, err = op.getText(run, onedex)
	}
	return
}

func (op *StoppingText) stopping(run rt.Runtime) (ret int, err error) {
	switch max := len(op.Parts); max {
	case 0:
		// no elements, nothing to do.
	case 1:
		// when one element, return it once then the empty string after.
		ret, err = op.updateCounter(run, saturate)
	default:
		ret, err = op.updateCounter(run, cap)
	}
	return
}

func makeIndices(max int) []int {
	indices := make([]int, max)
	for i := 0; i < max; i++ {
		indices[i] = i
	}
	return indices
}

func wrap(curr, max int) int {
	return (curr + 1) % max
}

func cap(curr, max int) int {
	if next := curr + 1; next < max {
		curr = next
	}
	return curr
}

func saturate(curr, max int) int {
	if curr < max {
		curr++
	}
	return curr
}
